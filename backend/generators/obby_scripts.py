"""Obby Scripts - Pre-built Lua scripts for Roblox obby games.

Replaces Claude API generation with hardcoded, production-ready Lua scripts.
Each script is a complete, working Roblox Lua script ready to be placed
in its designated location (ServerScriptService or StarterPlayerScripts).

All scripts reference parts generated by obby_generator.py using naming
conventions: Checkpoint_N, Kill*/KillFloor/KillBrick, Moving*, Disappear*,
Spin*, Teleport*, StageSign_N, etc.
"""


def get_obby_scripts(game_name: str, sections: list, stages: list) -> dict[str, dict]:
    """Get all Lua scripts needed for a complete obby game.

    Args:
        game_name: Display name of the game (e.g. "Epic Lava Obby")
        sections: List of section dicts with keys: name, theme, start_stage, end_stage
        stages: List of stage dicts with keys: stage, theme_name, position, etc.

    Returns:
        Dict mapping script name -> {"code": lua_string, "type": script_type, "location": placement}
    """
    total_stages = len(stages) if stages else 30

    # Build section data string for Lua embedding
    section_lua_entries = []
    if sections:
        for sec in sections:
            safe_name = sec.get("name", "Unknown").replace('"', '\\"')
            section_lua_entries.append(
                f'    {{name = "{safe_name}", theme = "{sec.get("theme", "lobby")}", '
                f'startStage = {sec.get("start_stage", 1)}, endStage = {sec.get("end_stage", 5)}}}'
            )
    else:
        section_lua_entries.append(
            '    {name = "The Obby", theme = "lobby", startStage = 1, endStage = '
            + str(total_stages) + '}'
        )
    sections_lua = ",\n".join(section_lua_entries)

    # Build stage position data for Lua
    stage_lua_entries = []
    if stages:
        for st in stages:
            pos = st.get("position", [0, 5, 0])
            tname = st.get("theme_name", "Unknown").replace('"', '\\"')
            stage_lua_entries.append(
                f'    [{st.get("stage", 1)}] = {{position = Vector3.new({pos[0]}, {pos[1]}, {pos[2]}), '
                f'themeName = "{tname}"}}'
            )
    stage_positions_lua = ",\n".join(stage_lua_entries) if stage_lua_entries else ""

    safe_game_name = game_name.replace('"', '\\"')

    return {
        "GameManager": {
            "code": _game_manager_script(safe_game_name, total_stages, sections_lua, stage_positions_lua),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "CheckpointSystem": {
            "code": _checkpoint_system_script(total_stages),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "KillBrickHandler": {
            "code": _kill_brick_handler_script(),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "MovingPlatforms": {
            "code": _moving_platforms_script(),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "TeleportPads": {
            "code": _teleport_pads_script(),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "DisappearingPlatforms": {
            "code": _disappearing_platforms_script(),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "SpinningObstacles": {
            "code": _spinning_obstacles_script(),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "LeaderboardManager": {
            "code": _leaderboard_manager_script(),
            "type": "ServerScript",
            "location": "ServerScriptService",
        },
        "ObbyHUD": {
            "code": _obby_hud_script(safe_game_name, total_stages, sections_lua),
            "type": "LocalScript",
            "location": "StarterPlayerScripts",
        },
        "SprintSystem": {
            "code": _sprint_system_script(),
            "type": "LocalScript",
            "location": "StarterPlayerScripts",
        },
        "ClientEffects": {
            "code": _client_effects_script(),
            "type": "LocalScript",
            "location": "StarterPlayerScripts",
        },
    }



# ============================================================
# GAME MANAGER (ServerScript - ServerScriptService)
# ============================================================

def _game_manager_script(game_name: str, total_stages: int, sections_lua: str, stage_positions_lua: str) -> str:
    return f'''-- GameManager: Core game orchestration for {game_name}
-- Handles player join/leave, leaderstats, stage tracking, DataStore persistence

local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")

local GAME_NAME = "{game_name}"
local TOTAL_STAGES = {total_stages}
local DATA_STORE_KEY = "ObbyPlayerData_v2"

-- DataStore setup
local playerDataStore = nil
pcall(function()
    playerDataStore = DataStoreService:GetDataStore(DATA_STORE_KEY)
end)

-- Create RemoteEvents in ReplicatedStorage
local function createRemote(name, className)
    className = className or "RemoteEvent"
    local existing = ReplicatedStorage:FindFirstChild(name)
    if existing then return existing end
    local remote = Instance.new(className)
    remote.Name = name
    remote.Parent = ReplicatedStorage
    return remote
end

local StageUpdatedEvent = createRemote("StageUpdated")
local PlayerDiedEvent = createRemote("PlayerDied")
local PlayerReachedStageEvent = createRemote("PlayerReachedStage")
local TeleportEffectEvent = createRemote("TeleportEffect")
local CheckpointReachedEvent = createRemote("CheckpointReached")
local VictoryEvent = createRemote("Victory")
local SectionChangedEvent = createRemote("SectionChanged")

-- Section definitions
local sections = {{
{sections_lua}
}}

-- Stage position data
local stageData = {{
{stage_positions_lua}
}}

-- Player data cache
local playerCache = {{}}

-- Get section for a stage number
local function getSectionForStage(stageNum)
    for _, section in ipairs(sections) do
        if stageNum >= section.startStage and stageNum <= section.endStage then
            return section
        end
    end
    return sections[#sections]
end

-- Load player data from DataStore
local function loadPlayerData(player)
    local data = {{
        currentStage = 1,
        highestStage = 1,
        deaths = 0,
        totalDeaths = 0,
        playTime = 0,
    }}

    if playerDataStore then
        local success, result = pcall(function()
            return playerDataStore:GetAsync("Player_" .. player.UserId)
        end)
        if success and result then
            data.currentStage = result.currentStage or 1
            data.highestStage = result.highestStage or 1
            data.totalDeaths = result.totalDeaths or 0
        end
    end

    playerCache[player.UserId] = data
    return data
end

-- Save player data to DataStore
local function savePlayerData(player)
    local data = playerCache[player.UserId]
    if not data or not playerDataStore then return end

    local success, err = pcall(function()
        playerDataStore:SetAsync("Player_" .. player.UserId, {{
            currentStage = data.currentStage,
            highestStage = data.highestStage,
            totalDeaths = data.totalDeaths,
            playTime = data.playTime,
        }})
    end)
    if not success then
        warn("[GameManager] Failed to save data for " .. player.Name .. ": " .. tostring(err))
    end
end

-- Set up leaderstats for a player
local function setupLeaderstats(player)
    local leaderstats = Instance.new("Folder")
    leaderstats.Name = "leaderstats"
    leaderstats.Parent = player

    local stageStat = Instance.new("IntValue")
    stageStat.Name = "Stage"
    stageStat.Value = 1
    stageStat.Parent = leaderstats

    return leaderstats
end

-- Update player stage
local function updatePlayerStage(player, newStage)
    local data = playerCache[player.UserId]
    if not data then return end

    newStage = math.clamp(newStage, 1, TOTAL_STAGES)
    data.currentStage = newStage

    if newStage > data.highestStage then
        data.highestStage = newStage
    end

    -- Update leaderstats
    local leaderstats = player:FindFirstChild("leaderstats")
    if leaderstats then
        local stageStat = leaderstats:FindFirstChild("Stage")
        if stageStat then
            stageStat.Value = newStage
        end
    end

    -- Notify client
    local section = getSectionForStage(newStage)
    StageUpdatedEvent:FireClient(player, {{
        stage = newStage,
        totalStages = TOTAL_STAGES,
        sectionName = section and section.name or "Unknown",
        sectionTheme = section and section.theme or "lobby",
    }})

    -- Check for section change
    local prevSection = getSectionForStage(newStage - 1)
    if section and prevSection and section.name ~= prevSection.name then
        SectionChangedEvent:FireClient(player, {{
            sectionName = section.name,
            sectionTheme = section.theme,
        }})
    end

    -- Check for victory
    if newStage >= TOTAL_STAGES then
        VictoryEvent:FireClient(player, {{
            totalDeaths = data.totalDeaths + data.deaths,
        }})
    end
end

-- Handle player death
local function onCharacterDied(player)
    local data = playerCache[player.UserId]
    if not data then return end

    data.deaths = data.deaths + 1
    data.totalDeaths = data.totalDeaths + 1
    PlayerDiedEvent:FireClient(player, {{
        deaths = data.deaths,
        totalDeaths = data.totalDeaths,
    }})
end

-- Handle character spawning
local function onCharacterAdded(player, character)
    local humanoid = character:WaitForChild("Humanoid", 10)
    if humanoid then
        humanoid.Died:Connect(function()
            onCharacterDied(player)
        end)
    end
end

-- Player joined
local function onPlayerAdded(player)
    local data = loadPlayerData(player)
    local leaderstats = setupLeaderstats(player)

    -- Set initial stage
    leaderstats:FindFirstChild("Stage").Value = data.currentStage

    -- Send initial state to client
    task.defer(function()
        local section = getSectionForStage(data.currentStage)
        StageUpdatedEvent:FireClient(player, {{
            stage = data.currentStage,
            totalStages = TOTAL_STAGES,
            sectionName = section and section.name or "Unknown",
            sectionTheme = section and section.theme or "lobby",
        }})
    end)

    -- Track character spawns
    player.CharacterAdded:Connect(function(character)
        onCharacterAdded(player, character)
    end)

    if player.Character then
        onCharacterAdded(player, player.Character)
    end
end

-- Player leaving
local function onPlayerRemoving(player)
    savePlayerData(player)
    playerCache[player.UserId] = nil
end

-- Listen for stage reach events from client/checkpoints
PlayerReachedStageEvent.OnServerEvent:Connect(function(player, stageNum)
    if type(stageNum) ~= "number" then return end
    stageNum = math.floor(stageNum)
    if stageNum < 1 or stageNum > TOTAL_STAGES then return end

    local data = playerCache[player.UserId]
    if not data then return end

    -- Only allow advancing by 1 stage at a time (anti-exploit)
    if stageNum <= data.currentStage + 1 then
        updatePlayerStage(player, stageNum)
    end
end)

-- Connect events
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Handle already-connected players (in case script loads late)
for _, player in ipairs(Players:GetPlayers()) do
    task.spawn(onPlayerAdded, player)
end

-- Auto-save every 60 seconds
task.spawn(function()
    while true do
        task.wait(60)
        for _, player in ipairs(Players:GetPlayers()) do
            task.spawn(savePlayerData, player)
        end
    end
end)

-- Save all data on server shutdown
game:BindToClose(function()
    for _, player in ipairs(Players:GetPlayers()) do
        savePlayerData(player)
    end
end)

print("[GameManager] Initialized for " .. GAME_NAME .. " with " .. TOTAL_STAGES .. " stages")
'''



# ============================================================
# CHECKPOINT SYSTEM (ServerScript - ServerScriptService)
# ============================================================

def _checkpoint_system_script(total_stages: int) -> str:
    return f'''-- CheckpointSystem: Handles checkpoint detection and respawn points
-- Finds all parts named Checkpoint_N in workspace and connects touch events

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

local TOTAL_STAGES = {total_stages}

-- Wait for remotes
local function waitForRemote(name)
    return ReplicatedStorage:WaitForChild(name, 10)
end

local StageUpdatedEvent = waitForRemote("StageUpdated")
local CheckpointReachedEvent = waitForRemote("CheckpointReached")
local PlayerReachedStageEvent = waitForRemote("PlayerReachedStage")

-- Debounce per player
local debounce = {{}}

-- Find all checkpoints in workspace
local function findCheckpoints()
    local checkpoints = {{}}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            local name = obj.Name
            -- Match Checkpoint_N pattern
            local stageNum = tonumber(name:match("Checkpoint_(%d+)"))
            if stageNum then
                checkpoints[stageNum] = obj
            end
        end
    end
    return checkpoints
end

-- Set up a single checkpoint
local function setupCheckpoint(part, stageNum)
    part.Touched:Connect(function(hit)
        local character = hit.Parent
        if not character then return end
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then return end

        local player = Players:GetPlayerFromCharacter(character)
        if not player then return end

        -- Debounce check
        local key = player.UserId .. "_" .. stageNum
        if debounce[key] then return end
        debounce[key] = true

        -- Get current stage
        local leaderstats = player:FindFirstChild("leaderstats")
        local currentStage = 1
        if leaderstats then
            local stageStat = leaderstats:FindFirstChild("Stage")
            if stageStat then
                currentStage = stageStat.Value
            end
        end

        -- Only advance if this checkpoint is the next stage or current
        if stageNum >= currentStage and stageNum <= currentStage + 1 then
            -- Update spawn location
            if part:IsA("SpawnLocation") then
                player.RespawnLocation = part
            else
                -- Create a temporary SpawnLocation at the checkpoint position
                local spawnLoc = workspace:FindFirstChild("SpawnCheckpoint_" .. player.UserId)
                if not spawnLoc then
                    spawnLoc = Instance.new("SpawnLocation")
                    spawnLoc.Name = "SpawnCheckpoint_" .. player.UserId
                    spawnLoc.Neutral = true
                    spawnLoc.AllowTeamChangeOnTouch = false
                    spawnLoc.Duration = 0
                    spawnLoc.Anchored = true
                    spawnLoc.CanCollide = false
                    spawnLoc.Transparency = 1
                    spawnLoc.Size = Vector3.new(6, 1, 6)
                    spawnLoc.Parent = workspace
                end
                spawnLoc.CFrame = part.CFrame + Vector3.new(0, 3, 0)
                player.RespawnLocation = spawnLoc
            end

            -- Fire stage update
            if stageNum > currentStage then
                PlayerReachedStageEvent:FireServer(stageNum)
                -- Also fire directly since we are server
                if leaderstats then
                    local stageStat = leaderstats:FindFirstChild("Stage")
                    if stageStat then
                        stageStat.Value = stageNum
                    end
                end
            end

            -- Notify client for checkpoint effect
            if CheckpointReachedEvent then
                CheckpointReachedEvent:FireClient(player, {{
                    stage = stageNum,
                    position = part.Position,
                }})
            end
        end

        -- Reset debounce after short delay
        task.delay(0.5, function()
            debounce[key] = nil
        end)
    end)
end

-- Initialize all checkpoints
local function init()
    local checkpoints = findCheckpoints()
    local count = 0

    for stageNum, part in pairs(checkpoints) do
        setupCheckpoint(part, stageNum)
        count = count + 1
    end

    -- Also handle CollectionService tagged checkpoints
    for _, part in ipairs(CollectionService:GetTagged("Checkpoint")) do
        if part:IsA("BasePart") then
            local stageNum = part:GetAttribute("Stage") or 0
            if stageNum > 0 and not checkpoints[stageNum] then
                setupCheckpoint(part, stageNum)
                count = count + 1
            end
        end
    end

    print("[CheckpointSystem] Set up " .. count .. " checkpoints")
end

-- Clean up spawn locations when player leaves
Players.PlayerRemoving:Connect(function(player)
    local spawnLoc = workspace:FindFirstChild("SpawnCheckpoint_" .. player.UserId)
    if spawnLoc then
        spawnLoc:Destroy()
    end
end)

-- Wait a moment for workspace to load, then initialize
task.wait(1)
init()
'''



# ============================================================
# KILL BRICK HANDLER (ServerScript - ServerScriptService)
# ============================================================

def _kill_brick_handler_script() -> str:
    return '''-- KillBrickHandler: Detects and handles kill bricks
-- Finds parts named with "Kill" or tagged with CollectionService "KillBrick"

local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerDiedEvent = ReplicatedStorage:WaitForChild("PlayerDied", 10)

-- Debounce per player to prevent multiple kills in rapid succession
local killDebounce = {}

-- Handle a kill brick being touched
local function onKillBrickTouched(hit, killPart)
    local character = hit.Parent
    if not character then return end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end

    local player = Players:GetPlayerFromCharacter(character)
    if not player then return end

    -- Debounce check (0.1s between kills)
    if killDebounce[player.UserId] then return end
    killDebounce[player.UserId] = true

    -- Kill the player
    humanoid.Health = 0

    -- Reset debounce after delay
    task.delay(0.5, function()
        killDebounce[player.UserId] = nil
    end)
end

-- Set up a kill brick
local function setupKillBrick(part)
    if not part:IsA("BasePart") then return end

    part.Touched:Connect(function(hit)
        onKillBrickTouched(hit, part)
    end)
end

-- Find all kill bricks by name pattern
local function findKillBricksByName()
    local count = 0
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            local name = obj.Name:lower()
            if name:find("kill") or name:find("lava") or name:find("killfloor") or name:find("killbrick") then
                setupKillBrick(obj)
                count = count + 1
            end
        end
    end
    return count
end

-- Find all kill bricks by CollectionService tag
local function findKillBricksByTag()
    local count = 0
    for _, obj in ipairs(CollectionService:GetTagged("KillBrick")) do
        setupKillBrick(obj)
        count = count + 1
    end

    -- Also watch for newly tagged objects
    CollectionService:GetInstanceAddedSignal("KillBrick"):Connect(function(obj)
        setupKillBrick(obj)
    end)

    return count
end

-- Find kill bricks by attribute
local function findKillBricksByAttribute()
    local count = 0
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj:GetAttribute("IsKillBrick") == true then
            setupKillBrick(obj)
            count = count + 1
        end
    end
    return count
end

-- Initialize
task.wait(1)
local nameCount = findKillBricksByName()
local tagCount = findKillBricksByTag()
local attrCount = findKillBricksByAttribute()
print("[KillBrickHandler] Set up " .. (nameCount + tagCount + attrCount) .. " kill bricks (" .. nameCount .. " by name, " .. tagCount .. " by tag, " .. attrCount .. " by attribute)")

-- Clean up debounce when player leaves
Players.PlayerRemoving:Connect(function(player)
    killDebounce[player.UserId] = nil
end)
'''



# ============================================================
# MOVING PLATFORMS (ServerScript - ServerScriptService)
# ============================================================

def _moving_platforms_script() -> str:
    return '''-- MovingPlatforms: Animates platforms that slide back and forth
-- Finds parts with "Moving" in the name, reads MoveAxis/MoveDistance/MoveSpeed attributes

local TweenService = game:GetService("TweenService")

-- Default movement parameters
local DEFAULT_AXIS = "x"
local DEFAULT_DISTANCE = 15
local DEFAULT_SPEED = 4
local DEFAULT_DELAY = 0.2

-- Set up a moving platform
local function setupMovingPlatform(part)
    if not part:IsA("BasePart") then return end

    -- Read attributes (with defaults)
    local moveAxis = part:GetAttribute("MoveAxis") or DEFAULT_AXIS
    local moveDistance = part:GetAttribute("MoveDistance") or DEFAULT_DISTANCE
    local moveSpeed = part:GetAttribute("MoveSpeed") or DEFAULT_SPEED
    local moveDelay = part:GetAttribute("MoveDelay") or DEFAULT_DELAY

    moveAxis = moveAxis:lower()

    -- Calculate duration from distance and speed
    local duration = moveDistance / moveSpeed

    -- Build the offset vector
    local offset = Vector3.new(0, 0, 0)
    if moveAxis == "x" then
        offset = Vector3.new(moveDistance, 0, 0)
    elseif moveAxis == "y" then
        offset = Vector3.new(0, moveDistance, 0)
    elseif moveAxis == "z" then
        offset = Vector3.new(0, 0, moveDistance)
    end

    local startPos = part.Position
    local endPos = startPos + offset

    -- Tween info for smooth sine motion
    local tweenInfoForward = TweenInfo.new(
        duration,
        Enum.EasingStyle.Sine,
        Enum.EasingDirection.InOut,
        0,     -- RepeatCount (0 = no repeat, we handle it manually)
        false, -- Reverses
        moveDelay
    )

    local tweenInfoBackward = TweenInfo.new(
        duration,
        Enum.EasingStyle.Sine,
        Enum.EasingDirection.InOut,
        0,
        false,
        moveDelay
    )

    -- Create tweens
    local tweenForward = TweenService:Create(part, tweenInfoForward, {Position = endPos})
    local tweenBackward = TweenService:Create(part, tweenInfoBackward, {Position = startPos})

    -- Chain tweens in a loop
    tweenForward.Completed:Connect(function()
        tweenBackward:Play()
    end)

    tweenBackward.Completed:Connect(function()
        tweenForward:Play()
    end)

    -- Start the animation
    tweenForward:Play()
end

-- Find all moving platforms
local function init()
    local count = 0
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name:lower():find("moving") then
            setupMovingPlatform(obj)
            count = count + 1
        end
    end
    print("[MovingPlatforms] Animated " .. count .. " moving platforms")
end

task.wait(1)
init()
'''



# ============================================================
# TELEPORT PADS (ServerScript - ServerScriptService)
# ============================================================

def _teleport_pads_script() -> str:
    return '''-- TeleportPads: Handles teleport pads that transport players to destinations
-- Finds parts with "Teleport" in name or tagged "TeleportPad"
-- Reads TeleportTo attribute (Vector3) for destination

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local TeleportEffectEvent = ReplicatedStorage:WaitForChild("TeleportEffect", 10)

-- Cooldown tracking per player
local cooldowns = {}
local COOLDOWN_TIME = 1.0

-- Flash effect on the pad itself
local function flashPad(part)
    local originalTransparency = part.Transparency
    local flashTween = TweenService:Create(part, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Transparency = 0.8
    })
    local resetTween = TweenService:Create(part, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Transparency = originalTransparency
    })

    flashTween.Completed:Connect(function()
        resetTween:Play()
    end)
    flashTween:Play()
end

-- Set up a teleport pad
local function setupTeleportPad(part)
    if not part:IsA("BasePart") then return end

    part.Touched:Connect(function(hit)
        local character = hit.Parent
        if not character then return end

        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then return end

        local player = Players:GetPlayerFromCharacter(character)
        if not player then return end

        -- Cooldown check
        local key = player.UserId
        if cooldowns[key] and tick() - cooldowns[key] < COOLDOWN_TIME then return end
        cooldowns[key] = tick()

        -- Get destination
        local destination = part:GetAttribute("TeleportTo")
        if not destination then
            -- Try to find a linked part
            local linkedPartName = part:GetAttribute("TeleportTarget")
            if linkedPartName then
                local targetPart = workspace:FindFirstChild(linkedPartName, true)
                if targetPart and targetPart:IsA("BasePart") then
                    destination = targetPart.Position + Vector3.new(0, 3, 0)
                end
            end
        end

        if not destination then return end

        -- Ensure destination is a Vector3
        if typeof(destination) ~= "Vector3" then return end

        -- Teleport the player
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            rootPart.CFrame = CFrame.new(destination)

            -- Fire visual effect to client
            if TeleportEffectEvent then
                TeleportEffectEvent:FireClient(player, {
                    fromPosition = part.Position,
                    toPosition = destination,
                })
            end

            -- Flash the pad
            flashPad(part)
        end
    end)
end

-- Find all teleport pads
local function init()
    local count = 0

    -- By name
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name:lower():find("teleport") then
            setupTeleportPad(obj)
            count = count + 1
        end
    end

    -- By tag
    for _, obj in ipairs(CollectionService:GetTagged("TeleportPad")) do
        if obj:IsA("BasePart") then
            setupTeleportPad(obj)
            count = count + 1
        end
    end

    -- Watch for new teleport pads
    CollectionService:GetInstanceAddedSignal("TeleportPad"):Connect(function(obj)
        if obj:IsA("BasePart") then
            setupTeleportPad(obj)
        end
    end)

    print("[TeleportPads] Set up " .. count .. " teleport pads")
end

-- Clean up on player leave
Players.PlayerRemoving:Connect(function(player)
    cooldowns[player.UserId] = nil
end)

task.wait(1)
init()
'''



# ============================================================
# DISAPPEARING PLATFORMS (ServerScript - ServerScriptService)
# ============================================================

def _disappearing_platforms_script() -> str:
    return '''-- DisappearingPlatforms: Platforms that fade in and out on a cycle
-- Finds parts with "Disappear" in name
-- Cycle: visible 3s -> fade out 0.5s -> invisible 2s -> fade in 0.5s
-- Staggered by index * 0.7s offset

local TweenService = game:GetService("TweenService")

local VISIBLE_DURATION = 3.0
local FADE_OUT_DURATION = 0.5
local INVISIBLE_DURATION = 2.0
local FADE_IN_DURATION = 0.5
local STAGGER_OFFSET = 0.7

-- Set up a disappearing platform cycle
local function setupDisappearingPlatform(part, index)
    if not part:IsA("BasePart") then return end

    -- Store original properties
    local originalTransparency = part.Transparency
    local originalCanCollide = part.CanCollide

    -- Tween info for fade out
    local fadeOutInfo = TweenInfo.new(
        FADE_OUT_DURATION,
        Enum.EasingStyle.Sine,
        Enum.EasingDirection.InOut
    )

    -- Tween info for fade in
    local fadeInInfo = TweenInfo.new(
        FADE_IN_DURATION,
        Enum.EasingStyle.Sine,
        Enum.EasingDirection.InOut
    )

    -- Tweens
    local fadeOutTween = TweenService:Create(part, fadeOutInfo, {
        Transparency = 1
    })

    local fadeInTween = TweenService:Create(part, fadeInInfo, {
        Transparency = originalTransparency
    })

    -- Cycle function
    local function runCycle()
        while part and part.Parent do
            -- Visible phase
            part.Transparency = originalTransparency
            part.CanCollide = originalCanCollide
            task.wait(VISIBLE_DURATION)

            -- Fade out
            fadeOutTween:Play()
            fadeOutTween.Completed:Wait()

            -- Invisible phase
            part.CanCollide = false
            task.wait(INVISIBLE_DURATION)

            -- Fade in
            fadeInTween:Play()
            fadeInTween.Completed:Wait()

            -- Restore collision
            part.CanCollide = originalCanCollide
        end
    end

    -- Start with stagger offset
    task.delay(index * STAGGER_OFFSET, function()
        task.spawn(runCycle)
    end)
end

-- Find and set up all disappearing platforms
local function init()
    local platforms = {}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name:lower():find("disappear") then
            table.insert(platforms, obj)
        end
    end

    -- Sort by name for consistent stagger ordering
    table.sort(platforms, function(a, b)
        return a.Name < b.Name
    end)

    for i, platform in ipairs(platforms) do
        setupDisappearingPlatform(platform, i - 1)
    end

    print("[DisappearingPlatforms] Set up " .. #platforms .. " disappearing platforms")
end

task.wait(1)
init()
'''



# ============================================================
# SPINNING OBSTACLES (ServerScript - ServerScriptService)
# ============================================================

def _spinning_obstacles_script() -> str:
    return '''-- SpinningObstacles: Rotates parts continuously using RunService.Heartbeat
-- Finds parts with "Spin" in name, reads SpinSpeed attribute (degrees/sec)

local RunService = game:GetService("RunService")

local DEFAULT_SPIN_SPEED = 45  -- degrees per second
local DEFAULT_SPIN_AXIS = "y"  -- y-axis rotation by default

-- Collect all spinning obstacles
local spinners = {}

local function setupSpinner(part)
    if not part:IsA("BasePart") then return end

    local spinSpeed = part:GetAttribute("SpinSpeed") or DEFAULT_SPIN_SPEED
    local spinAxis = (part:GetAttribute("SpinAxis") or DEFAULT_SPIN_AXIS):lower()

    -- Convert degrees to radians per second
    local radiansPerSec = math.rad(spinSpeed)

    table.insert(spinners, {
        part = part,
        radiansPerSec = radiansPerSec,
        axis = spinAxis,
    })
end

-- Find all spinning obstacles
local function init()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name:lower():find("spin") then
            setupSpinner(obj)
        end
    end

    print("[SpinningObstacles] Set up " .. #spinners .. " spinning obstacles")
end

task.wait(1)
init()

-- Rotate all spinners each frame
RunService.Heartbeat:Connect(function(deltaTime)
    for _, spinner in ipairs(spinners) do
        local part = spinner.part
        if part and part.Parent then
            local angle = spinner.radiansPerSec * deltaTime
            local rotationCFrame

            if spinner.axis == "x" then
                rotationCFrame = CFrame.Angles(angle, 0, 0)
            elseif spinner.axis == "z" then
                rotationCFrame = CFrame.Angles(0, 0, angle)
            else
                -- Default: Y axis
                rotationCFrame = CFrame.Angles(0, angle, 0)
            end

            part.CFrame = part.CFrame * rotationCFrame
        end
    end
end)
'''



# ============================================================
# LEADERBOARD MANAGER (ServerScript - ServerScriptService)
# ============================================================

def _leaderboard_manager_script() -> str:
    return '''-- LeaderboardManager: Saves/loads highest stage per player using DataStore
-- Creates an OrderedDataStore for global leaderboard
-- Optionally populates a SurfaceGui on a part named "LeaderboardDisplay"

local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local TweenService = game:GetService("TweenService")

-- DataStores
local highestStageStore = nil
local leaderboardStore = nil

pcall(function()
    highestStageStore = DataStoreService:GetDataStore("HighestStage_v1")
end)

pcall(function()
    leaderboardStore = DataStoreService:GetOrderedDataStore("GlobalLeaderboard_v1")
end)

-- Update the global leaderboard for a player
local function updateLeaderboard(player, highestStage)
    if not leaderboardStore then return end

    local success, err = pcall(function()
        leaderboardStore:SetAsync(tostring(player.UserId), highestStage)
    end)
    if not success then
        warn("[LeaderboardManager] Failed to update leaderboard: " .. tostring(err))
    end
end

-- Get top players from leaderboard
local function getTopPlayers(count)
    count = count or 10
    if not leaderboardStore then return {} end

    local success, pages = pcall(function()
        return leaderboardStore:GetSortedAsync(false, count)
    end)

    if not success or not pages then return {} end

    local topPlayers = {}
    local pageData = pages:GetCurrentPage()

    for rank, entry in ipairs(pageData) do
        local userId = tonumber(entry.key)
        local stage = entry.value
        local playerName = "Player"

        -- Try to get the player name
        local nameSuccess, name = pcall(function()
            return Players:GetNameFromUserIdAsync(userId)
        end)
        if nameSuccess and name then
            playerName = name
        end

        table.insert(topPlayers, {
            rank = rank,
            name = playerName,
            userId = userId,
            stage = stage,
        })
    end

    return topPlayers
end

-- Create/update SurfaceGui leaderboard display
local function updateLeaderboardDisplay()
    local displayPart = workspace:FindFirstChild("LeaderboardDisplay", true)
    if not displayPart or not displayPart:IsA("BasePart") then return end

    -- Remove existing gui
    local existingGui = displayPart:FindFirstChild("LeaderboardGui")
    if existingGui then
        existingGui:Destroy()
    end

    -- Create SurfaceGui
    local gui = Instance.new("SurfaceGui")
    gui.Name = "LeaderboardGui"
    gui.Face = Enum.NormalId.Front
    gui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
    gui.PixelsPerStud = 50
    gui.Parent = displayPart

    -- Background frame
    local bg = Instance.new("Frame")
    bg.Size = UDim2.new(1, 0, 1, 0)
    bg.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    bg.BackgroundTransparency = 0.1
    bg.BorderSizePixel = 0
    bg.Parent = gui

    -- Title
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 60)
    title.Position = UDim2.new(0, 0, 0, 10)
    title.BackgroundTransparency = 1
    title.Text = "TOP PLAYERS"
    title.TextColor3 = Color3.fromRGB(255, 215, 0)
    title.TextSize = 36
    title.Font = Enum.Font.GothamBold
    title.Parent = bg

    -- Add UICorner
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = bg

    -- Get top players
    local topPlayers = getTopPlayers(10)

    for i, playerData in ipairs(topPlayers) do
        local entry = Instance.new("TextLabel")
        entry.Size = UDim2.new(0.9, 0, 0, 35)
        entry.Position = UDim2.new(0.05, 0, 0, 70 + (i - 1) * 40)
        entry.BackgroundTransparency = 0.7

        -- Top 3 get special colors
        if i == 1 then
            entry.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
        elseif i == 2 then
            entry.BackgroundColor3 = Color3.fromRGB(192, 192, 192)
        elseif i == 3 then
            entry.BackgroundColor3 = Color3.fromRGB(205, 127, 50)
        else
            entry.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
        end

        entry.Text = string.format("  #%d  %s  -  Stage %d", playerData.rank, playerData.name, playerData.stage)
        entry.TextColor3 = Color3.fromRGB(255, 255, 255)
        entry.TextSize = 22
        entry.Font = Enum.Font.GothamMedium
        entry.TextXAlignment = Enum.TextXAlignment.Left
        entry.Parent = bg

        local entryCorner = Instance.new("UICorner")
        entryCorner.CornerRadius = UDim.new(0, 6)
        entryCorner.Parent = entry
    end

    if #topPlayers == 0 then
        local noData = Instance.new("TextLabel")
        noData.Size = UDim2.new(0.8, 0, 0, 40)
        noData.Position = UDim2.new(0.1, 0, 0.4, 0)
        noData.BackgroundTransparency = 1
        noData.Text = "No records yet! Be the first!"
        noData.TextColor3 = Color3.fromRGB(180, 180, 200)
        noData.TextSize = 20
        noData.Font = Enum.Font.GothamMedium
        noData.Parent = bg
    end
end

-- Watch for stage changes and update leaderboard
local function onStageChanged(player)
    local leaderstats = player:FindFirstChild("leaderstats")
    if not leaderstats then return end

    local stageStat = leaderstats:FindFirstChild("Stage")
    if not stageStat then return end

    stageStat.Changed:Connect(function(newStage)
        updateLeaderboard(player, newStage)
    end)
end

-- Initialize
Players.PlayerAdded:Connect(function(player)
    task.wait(2)  -- Wait for leaderstats to be created
    onStageChanged(player)
end)

-- Update display periodically
task.spawn(function()
    while true do
        pcall(updateLeaderboardDisplay)
        task.wait(30)  -- Refresh every 30 seconds
    end
end)

-- Handle existing players
for _, player in ipairs(Players:GetPlayers()) do
    task.spawn(function()
        onStageChanged(player)
    end)
end

print("[LeaderboardManager] Initialized")
'''



# ============================================================
# OBBY HUD (LocalScript - StarterPlayerScripts)
# ============================================================

def _obby_hud_script(game_name: str, total_stages: int, sections_lua: str) -> str:
    return f'''-- ObbyHUD: Flashy heads-up display for the obby
-- Shows stage counter, section name, timer, death counter, sprint indicator
-- Handles stage change animations, death flash, victory celebration

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local GAME_NAME = "{game_name}"
local TOTAL_STAGES = {total_stages}

-- Section definitions (mirrored from server)
local sections = {{
{sections_lua}
}}

-- Wait for remote events
local function waitRemote(name)
    return ReplicatedStorage:WaitForChild(name, 15)
end

local StageUpdatedEvent = waitRemote("StageUpdated")
local PlayerDiedEvent = waitRemote("PlayerDied")
local VictoryEvent = waitRemote("Victory")
local SectionChangedEvent = waitRemote("SectionChanged")
local CheckpointReachedEvent = waitRemote("CheckpointReached")

-- State
local currentStage = 1
local currentSection = sections[1] and sections[1].name or "The Obby"
local deathCount = 0
local startTime = tick()
local isVictory = false

-- ============================================================
-- CREATE THE HUD
-- ============================================================

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ObbyHUD"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.IgnoreGuiInset = false
screenGui.Parent = playerGui

-- ---- Top Center: Stage Counter ----
local topCenterFrame = Instance.new("Frame")
topCenterFrame.Name = "TopCenter"
topCenterFrame.Size = UDim2.new(0, 320, 0, 90)
topCenterFrame.Position = UDim2.new(0.5, -160, 0, 8)
topCenterFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 20)
topCenterFrame.BackgroundTransparency = 0.3
topCenterFrame.BorderSizePixel = 0
topCenterFrame.Parent = screenGui

local topCenterCorner = Instance.new("UICorner")
topCenterCorner.CornerRadius = UDim.new(0, 12)
topCenterCorner.Parent = topCenterFrame

local topCenterStroke = Instance.new("UIStroke")
topCenterStroke.Color = Color3.fromRGB(255, 215, 0)
topCenterStroke.Thickness = 2
topCenterStroke.Transparency = 0.3
topCenterStroke.Parent = topCenterFrame

-- Stage text
local stageLabel = Instance.new("TextLabel")
stageLabel.Name = "StageLabel"
stageLabel.Size = UDim2.new(1, -20, 0, 40)
stageLabel.Position = UDim2.new(0, 10, 0, 5)
stageLabel.BackgroundTransparency = 1
stageLabel.Text = "Stage 1 / " .. TOTAL_STAGES
stageLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
stageLabel.TextSize = 32
stageLabel.Font = Enum.Font.GothamBold
stageLabel.TextXAlignment = Enum.TextXAlignment.Center
stageLabel.Parent = topCenterFrame

-- Section name
local sectionLabel = Instance.new("TextLabel")
sectionLabel.Name = "SectionLabel"
sectionLabel.Size = UDim2.new(1, -20, 0, 30)
sectionLabel.Position = UDim2.new(0, 10, 0, 48)
sectionLabel.BackgroundTransparency = 1
sectionLabel.Text = currentSection
sectionLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
sectionLabel.TextSize = 20
sectionLabel.Font = Enum.Font.GothamMedium
sectionLabel.TextXAlignment = Enum.TextXAlignment.Center
sectionLabel.Parent = topCenterFrame

-- ---- Top Right: Timer + Deaths ----
local topRightFrame = Instance.new("Frame")
topRightFrame.Name = "TopRight"
topRightFrame.Size = UDim2.new(0, 200, 0, 75)
topRightFrame.Position = UDim2.new(1, -210, 0, 8)
topRightFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 20)
topRightFrame.BackgroundTransparency = 0.3
topRightFrame.BorderSizePixel = 0
topRightFrame.Parent = screenGui

local topRightCorner = Instance.new("UICorner")
topRightCorner.CornerRadius = UDim.new(0, 12)
topRightCorner.Parent = topRightFrame

local topRightStroke = Instance.new("UIStroke")
topRightStroke.Color = Color3.fromRGB(100, 150, 255)
topRightStroke.Thickness = 2
topRightStroke.Transparency = 0.4
topRightStroke.Parent = topRightFrame

-- Timer label
local timerLabel = Instance.new("TextLabel")
timerLabel.Name = "TimerLabel"
timerLabel.Size = UDim2.new(1, -16, 0, 32)
timerLabel.Position = UDim2.new(0, 8, 0, 5)
timerLabel.BackgroundTransparency = 1
timerLabel.Text = "00:00"
timerLabel.TextColor3 = Color3.fromRGB(200, 220, 255)
timerLabel.TextSize = 26
timerLabel.Font = Enum.Font.Code
timerLabel.TextXAlignment = Enum.TextXAlignment.Center
timerLabel.Parent = topRightFrame

-- Death counter
local deathLabel = Instance.new("TextLabel")
deathLabel.Name = "DeathLabel"
deathLabel.Size = UDim2.new(1, -16, 0, 28)
deathLabel.Position = UDim2.new(0, 8, 0, 40)
deathLabel.BackgroundTransparency = 1
deathLabel.Text = "Deaths: 0"
deathLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
deathLabel.TextSize = 20
deathLabel.Font = Enum.Font.GothamMedium
deathLabel.TextXAlignment = Enum.TextXAlignment.Center
deathLabel.Parent = topRightFrame

-- ---- Bottom Center: Sprint Indicator ----
local sprintFrame = Instance.new("Frame")
sprintFrame.Name = "SprintIndicator"
sprintFrame.Size = UDim2.new(0, 300, 0, 40)
sprintFrame.Position = UDim2.new(0.5, -150, 1, -55)
sprintFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 20)
sprintFrame.BackgroundTransparency = 0.5
sprintFrame.BorderSizePixel = 0
sprintFrame.Parent = screenGui

local sprintCorner = Instance.new("UICorner")
sprintCorner.CornerRadius = UDim.new(0, 10)
sprintCorner.Parent = sprintFrame

local sprintLabel = Instance.new("TextLabel")
sprintLabel.Name = "SprintLabel"
sprintLabel.Size = UDim2.new(1, 0, 1, 0)
sprintLabel.BackgroundTransparency = 1
sprintLabel.Text = "HOLD SHIFT TO SPRINT"
sprintLabel.TextColor3 = Color3.fromRGB(180, 255, 180)
sprintLabel.TextSize = 18
sprintLabel.Font = Enum.Font.GothamBold
sprintLabel.TextXAlignment = Enum.TextXAlignment.Center
sprintLabel.Parent = sprintFrame

-- ---- Death Flash Overlay ----
local deathFlash = Instance.new("Frame")
deathFlash.Name = "DeathFlash"
deathFlash.Size = UDim2.new(1, 0, 1, 0)
deathFlash.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
deathFlash.BackgroundTransparency = 1
deathFlash.BorderSizePixel = 0
deathFlash.ZIndex = 100
deathFlash.Parent = screenGui

-- ---- Victory Overlay ----
local victoryFrame = Instance.new("Frame")
victoryFrame.Name = "VictoryOverlay"
victoryFrame.Size = UDim2.new(1, 0, 1, 0)
victoryFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
victoryFrame.BackgroundTransparency = 1
victoryFrame.BorderSizePixel = 0
victoryFrame.ZIndex = 200
victoryFrame.Visible = false
victoryFrame.Parent = screenGui

local victoryText = Instance.new("TextLabel")
victoryText.Name = "VictoryText"
victoryText.Size = UDim2.new(1, 0, 0, 120)
victoryText.Position = UDim2.new(0, 0, 0.3, 0)
victoryText.BackgroundTransparency = 1
victoryText.Text = "YOU WIN!"
victoryText.TextColor3 = Color3.fromRGB(255, 215, 0)
victoryText.TextSize = 72
victoryText.Font = Enum.Font.GothamBold
victoryText.TextStrokeColor3 = Color3.fromRGB(200, 150, 0)
victoryText.TextStrokeTransparency = 0.3
victoryText.ZIndex = 201
victoryText.Parent = victoryFrame

local victorySubtext = Instance.new("TextLabel")
victorySubtext.Name = "VictorySubtext"
victorySubtext.Size = UDim2.new(1, 0, 0, 50)
victorySubtext.Position = UDim2.new(0, 0, 0.3, 130)
victorySubtext.BackgroundTransparency = 1
victorySubtext.Text = "Congratulations!"
victorySubtext.TextColor3 = Color3.fromRGB(255, 255, 200)
victorySubtext.TextSize = 30
victorySubtext.Font = Enum.Font.GothamMedium
victorySubtext.ZIndex = 201
victorySubtext.Parent = victoryFrame

-- ============================================================
-- HUD UPDATE FUNCTIONS
-- ============================================================

-- Format time as MM:SS
local function formatTime(seconds)
    local mins = math.floor(seconds / 60)
    local secs = math.floor(seconds % 60)
    return string.format("%02d:%02d", mins, secs)
end

-- Update timer every frame
RunService.Heartbeat:Connect(function()
    if not isVictory then
        local elapsed = tick() - startTime
        timerLabel.Text = formatTime(elapsed)
    end
end)

-- Animate stage change (scale pulse + color flash)
local function animateStageChange(newStage)
    -- Scale pulse
    local originalSize = stageLabel.TextSize

    local growTween = TweenService:Create(stageLabel, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {{
        TextSize = originalSize + 12
    }})

    local shrinkTween = TweenService:Create(stageLabel, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {{
        TextSize = originalSize
    }})

    -- Color flash: yellow -> white
    stageLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
    local colorTween = TweenService:Create(stageLabel, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {{
        TextColor3 = Color3.fromRGB(255, 255, 255)
    }})

    growTween.Completed:Connect(function()
        shrinkTween:Play()
    end)

    growTween:Play()
    colorTween:Play()

    -- Also pulse the frame border
    topCenterStroke.Color = Color3.fromRGB(255, 255, 100)
    topCenterStroke.Transparency = 0
    TweenService:Create(topCenterStroke, TweenInfo.new(0.8, Enum.EasingStyle.Sine), {{
        Color = Color3.fromRGB(255, 215, 0),
        Transparency = 0.3
    }}):Play()
end

-- Flash screen red on death
local function animateDeath()
    deathFlash.BackgroundTransparency = 0.5
    TweenService:Create(deathFlash, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {{
        BackgroundTransparency = 1
    }}):Play()
end

-- Victory celebration
local function showVictory(data)
    isVictory = true
    victoryFrame.Visible = true

    -- Fade in background
    TweenService:Create(victoryFrame, TweenInfo.new(1.0, Enum.EasingStyle.Sine), {{
        BackgroundTransparency = 0.4
    }}):Play()

    -- Animate victory text scale
    victoryText.TextSize = 20
    TweenService:Create(victoryText, TweenInfo.new(0.8, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {{
        TextSize = 72
    }}):Play()

    -- Show final stats
    local elapsed = tick() - startTime
    local totalDeaths = data and data.totalDeaths or deathCount
    victorySubtext.Text = string.format("Time: %s  |  Deaths: %d", formatTime(elapsed), totalDeaths)

    -- Create firework-like particles (colored dots that fly around)
    task.spawn(function()
        for i = 1, 20 do
            local particle = Instance.new("Frame")
            particle.Size = UDim2.new(0, math.random(4, 12), 0, math.random(4, 12))
            particle.Position = UDim2.new(math.random() * 0.8 + 0.1, 0, math.random() * 0.6 + 0.2, 0)
            particle.BackgroundColor3 = Color3.fromHSV(math.random(), 0.8, 1)
            particle.BorderSizePixel = 0
            particle.ZIndex = 202
            particle.Parent = victoryFrame

            local particleCorner = Instance.new("UICorner")
            particleCorner.CornerRadius = UDim.new(1, 0)
            particleCorner.Parent = particle

            -- Animate upward and fade
            local targetY = particle.Position.Y.Scale - math.random() * 0.3 - 0.1
            TweenService:Create(particle, TweenInfo.new(math.random() * 1.5 + 0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {{
                Position = UDim2.new(particle.Position.X.Scale + (math.random() - 0.5) * 0.2, 0, targetY, 0),
                BackgroundTransparency = 1,
                Size = UDim2.new(0, 2, 0, 2)
            }}):Play()

            task.delay(2, function()
                if particle and particle.Parent then
                    particle:Destroy()
                end
            end)

            task.wait(0.1)
        end
    end)
end

-- ============================================================
-- EVENT LISTENERS
-- ============================================================

-- Stage updated from server
if StageUpdatedEvent then
    StageUpdatedEvent.OnClientEvent:Connect(function(data)
        if not data then return end

        local newStage = data.stage or currentStage
        local sectionName = data.sectionName or currentSection

        if newStage ~= currentStage then
            animateStageChange(newStage)
        end

        currentStage = newStage
        currentSection = sectionName

        stageLabel.Text = "Stage " .. currentStage .. " / " .. TOTAL_STAGES
        sectionLabel.Text = sectionName
    end)
end

-- Player died
if PlayerDiedEvent then
    PlayerDiedEvent.OnClientEvent:Connect(function(data)
        if data then
            deathCount = data.deaths or (deathCount + 1)
        else
            deathCount = deathCount + 1
        end
        deathLabel.Text = "Deaths: " .. deathCount
        animateDeath()
    end)
end

-- Victory
if VictoryEvent then
    VictoryEvent.OnClientEvent:Connect(function(data)
        showVictory(data)
    end)
end

-- Section changed
if SectionChangedEvent then
    SectionChangedEvent.OnClientEvent:Connect(function(data)
        if data and data.sectionName then
            currentSection = data.sectionName
            sectionLabel.Text = data.sectionName

            -- Flash section label
            sectionLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
            TweenService:Create(sectionLabel, TweenInfo.new(0.8, Enum.EasingStyle.Sine), {{
                TextColor3 = Color3.fromRGB(255, 200, 100)
            }}):Play()
        end
    end)
end

-- Sprint state listener (from SprintSystem via BindableEvent)
local sprintBindable = Instance.new("BindableEvent")
sprintBindable.Name = "SprintStateChanged"
sprintBindable.Parent = player

sprintBindable.Event:Connect(function(isSprinting)
    if isSprinting then
        sprintLabel.Text = "SPRINTING!"
        sprintLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        TweenService:Create(sprintFrame, TweenInfo.new(0.2), {{
            BackgroundTransparency = 0.3
        }}):Play()
    else
        sprintLabel.Text = "HOLD SHIFT TO SPRINT"
        sprintLabel.TextColor3 = Color3.fromRGB(180, 255, 180)
        TweenService:Create(sprintFrame, TweenInfo.new(0.3), {{
            BackgroundTransparency = 0.5
        }}):Play()
    end
end)

print("[ObbyHUD] Initialized for " .. GAME_NAME)
'''



# ============================================================
# SPRINT SYSTEM (LocalScript - StarterPlayerScripts)
# ============================================================

def _sprint_system_script() -> str:
    return '''-- SprintSystem: Hold Left Shift to sprint (WalkSpeed 16 -> 24)
-- Creates subtle speed line particles on the character
-- Communicates sprint state to ObbyHUD via BindableEvent

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local WALK_SPEED = 16
local SPRINT_SPEED = 24
local SPRINT_KEY = Enum.KeyCode.LeftShift

local isSprinting = false

-- Get or wait for sprint state bindable (created by ObbyHUD)
local function getSprintBindable()
    return player:WaitForChild("SprintStateChanged", 5)
end

-- Notify HUD of sprint state
local function notifySprintState(sprinting)
    local bindable = getSprintBindable()
    if bindable then
        bindable:Fire(sprinting)
    end
end

-- Create speed line particle effect on character
local sprintParticles = nil

local function createSprintParticles(rootPart)
    if sprintParticles then return end

    local attachment = Instance.new("Attachment")
    attachment.Name = "SprintAttachment"
    attachment.Position = Vector3.new(0, 0, 1)
    attachment.Parent = rootPart

    local particles = Instance.new("ParticleEmitter")
    particles.Name = "SprintLines"
    particles.Texture = "rbxassetid://6823373478"  -- Default trail texture
    particles.Rate = 0
    particles.Lifetime = NumberRange.new(0.2, 0.4)
    particles.Speed = NumberRange.new(5, 10)
    particles.SpreadAngle = Vector2.new(10, 10)
    particles.EmissionDirection = Enum.NormalId.Back
    particles.Color = ColorSequence.new(Color3.fromRGB(200, 220, 255))
    particles.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(1, 1),
    })
    particles.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.3),
        NumberSequenceKeypoint.new(1, 0),
    })
    particles.LightEmission = 0.5
    particles.Parent = attachment

    sprintParticles = {
        attachment = attachment,
        emitter = particles,
    }
end

local function enableSprintParticles()
    if sprintParticles and sprintParticles.emitter then
        sprintParticles.emitter.Rate = 30
    end
end

local function disableSprintParticles()
    if sprintParticles and sprintParticles.emitter then
        sprintParticles.emitter.Rate = 0
    end
end

-- Set sprint state
local function setSprinting(sprinting)
    if isSprinting == sprinting then return end
    isSprinting = sprinting

    local humanoid = nil
    if character then
        humanoid = character:FindFirstChild("Humanoid")
    end

    if humanoid then
        if sprinting then
            humanoid.WalkSpeed = SPRINT_SPEED
            enableSprintParticles()
        else
            humanoid.WalkSpeed = WALK_SPEED
            disableSprintParticles()
        end
    end

    notifySprintState(sprinting)
end

-- Input handlers
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == SPRINT_KEY then
        setSprinting(true)
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.KeyCode == SPRINT_KEY then
        setSprinting(false)
    end
end)

-- Handle character respawn
local function onCharacterAdded(newCharacter)
    character = newCharacter

    -- Clean up old particles
    sprintParticles = nil
    isSprinting = false

    local humanoid = newCharacter:WaitForChild("Humanoid", 10)
    if humanoid then
        humanoid.WalkSpeed = WALK_SPEED
    end

    local rootPart = newCharacter:WaitForChild("HumanoidRootPart", 10)
    if rootPart then
        createSprintParticles(rootPart)
    end

    notifySprintState(false)
end

player.CharacterAdded:Connect(onCharacterAdded)

-- Initialize with current character
if character then
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        createSprintParticles(rootPart)
    end
end

print("[SprintSystem] Initialized - Hold Left Shift to sprint")
'''



# ============================================================
# CLIENT EFFECTS (LocalScript - StarterPlayerScripts)
# ============================================================

def _client_effects_script() -> str:
    return '''-- ClientEffects: Handles visual/audio effects on the client
-- Teleport flash, checkpoint gold particles, death camera shake,
-- stage completion mini-celebration, ambient section particles

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- Wait for remote events
local function waitRemote(name)
    return ReplicatedStorage:WaitForChild(name, 15)
end

local TeleportEffectEvent = waitRemote("TeleportEffect")
local CheckpointReachedEvent = waitRemote("CheckpointReached")
local StageUpdatedEvent = waitRemote("StageUpdated")
local PlayerDiedEvent = waitRemote("PlayerDied")
local SectionChangedEvent = waitRemote("SectionChanged")

local playerGui = player:WaitForChild("PlayerGui")

-- ============================================================
-- TELEPORT FLASH EFFECT
-- ============================================================

local function createTeleportFlash()
    -- Create a white flash overlay that fades away
    local flash = Instance.new("Frame")
    flash.Name = "TeleportFlash"
    flash.Size = UDim2.new(1, 0, 1, 0)
    flash.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    flash.BackgroundTransparency = 0.2
    flash.BorderSizePixel = 0
    flash.ZIndex = 150
    flash.Parent = playerGui:FindFirstChild("ObbyHUD") or playerGui

    -- Fade out
    local fadeTween = TweenService:Create(flash, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
        BackgroundTransparency = 1
    })

    fadeTween.Completed:Connect(function()
        flash:Destroy()
    end)

    fadeTween:Play()
end

if TeleportEffectEvent then
    TeleportEffectEvent.OnClientEvent:Connect(function(data)
        createTeleportFlash()
    end)
end

-- ============================================================
-- CHECKPOINT REACHED EFFECT
-- ============================================================

local function createCheckpointEffect(position)
    -- Gold particles burst at checkpoint position
    local character = player.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    -- Create temporary attachment for particles
    local attachment = Instance.new("Attachment")
    attachment.Position = Vector3.new(0, 2, 0)
    attachment.Parent = rootPart

    local particles = Instance.new("ParticleEmitter")
    particles.Texture = "rbxassetid://6823373478"
    particles.Rate = 0
    particles.Lifetime = NumberRange.new(0.8, 1.5)
    particles.Speed = NumberRange.new(8, 15)
    particles.SpreadAngle = Vector2.new(180, 180)
    particles.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 215, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 180, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 100)),
    })
    particles.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.7, 0.3),
        NumberSequenceKeypoint.new(1, 1),
    })
    particles.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.5),
        NumberSequenceKeypoint.new(0.5, 0.3),
        NumberSequenceKeypoint.new(1, 0),
    })
    particles.LightEmission = 1
    particles.Parent = attachment

    -- Emit burst
    particles:Emit(25)

    -- Play a sound cue
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://6042053626"  -- Coin/achievement sound
    sound.Volume = 0.5
    sound.PlaybackSpeed = 1.2
    sound.Parent = rootPart
    sound:Play()

    -- Clean up after particles finish
    task.delay(2, function()
        if attachment and attachment.Parent then
            attachment:Destroy()
        end
        if sound and sound.Parent then
            sound:Destroy()
        end
    end)

    -- Also show a brief text popup
    local screenGui = playerGui:FindFirstChild("ObbyHUD")
    if screenGui then
        local popup = Instance.new("TextLabel")
        popup.Size = UDim2.new(0, 250, 0, 40)
        popup.Position = UDim2.new(0.5, -125, 0.6, 0)
        popup.BackgroundTransparency = 1
        popup.Text = "CHECKPOINT!"
        popup.TextColor3 = Color3.fromRGB(255, 215, 0)
        popup.TextSize = 28
        popup.Font = Enum.Font.GothamBold
        popup.TextStrokeColor3 = Color3.fromRGB(150, 100, 0)
        popup.TextStrokeTransparency = 0.3
        popup.ZIndex = 50
        popup.Parent = screenGui

        -- Animate upward and fade
        TweenService:Create(popup, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
            Position = UDim2.new(0.5, -125, 0.5, 0),
            TextTransparency = 1,
            TextStrokeTransparency = 1,
        }):Play()

        task.delay(1.5, function()
            if popup and popup.Parent then
                popup:Destroy()
            end
        end)
    end
end

if CheckpointReachedEvent then
    CheckpointReachedEvent.OnClientEvent:Connect(function(data)
        local pos = data and data.position or nil
        createCheckpointEffect(pos)
    end)
end

-- ============================================================
-- DEATH CAMERA SHAKE
-- ============================================================

local shakeConnection = nil

local function cameraShake(duration, intensity)
    local startTime = tick()
    local originalCFrame = camera.CFrame

    -- Disconnect any existing shake
    if shakeConnection then
        shakeConnection:Disconnect()
        shakeConnection = nil
    end

    shakeConnection = RunService.RenderStepped:Connect(function()
        local elapsed = tick() - startTime
        if elapsed > duration then
            shakeConnection:Disconnect()
            shakeConnection = nil
            return
        end

        -- Decreasing intensity over time
        local progress = elapsed / duration
        local currentIntensity = intensity * (1 - progress)

        local offsetX = (math.random() - 0.5) * 2 * currentIntensity
        local offsetY = (math.random() - 0.5) * 2 * currentIntensity

        camera.CFrame = camera.CFrame * CFrame.new(offsetX, offsetY, 0)
    end)
end

if PlayerDiedEvent then
    PlayerDiedEvent.OnClientEvent:Connect(function()
        cameraShake(0.4, 0.5)
    end)
end

-- Also detect death through humanoid
local function watchCharacterDeath(newCharacter)
    local humanoid = newCharacter:WaitForChild("Humanoid", 10)
    if humanoid then
        humanoid.Died:Connect(function()
            cameraShake(0.4, 0.5)
        end)
    end
end

player.CharacterAdded:Connect(watchCharacterDeath)
if player.Character then
    task.spawn(watchCharacterDeath, player.Character)
end

-- ============================================================
-- STAGE COMPLETION MINI-CELEBRATION
-- ============================================================

local lastStage = 0

if StageUpdatedEvent then
    StageUpdatedEvent.OnClientEvent:Connect(function(data)
        if not data then return end
        local newStage = data.stage or 0

        -- Only celebrate if advancing (not loading saved data)
        if newStage > lastStage and lastStage > 0 then
            -- Small screen flash
            local screenGui = playerGui:FindFirstChild("ObbyHUD")
            if screenGui then
                local celebration = Instance.new("Frame")
                celebration.Size = UDim2.new(1, 0, 1, 0)
                celebration.BackgroundColor3 = Color3.fromRGB(255, 255, 200)
                celebration.BackgroundTransparency = 0.85
                celebration.BorderSizePixel = 0
                celebration.ZIndex = 90
                celebration.Parent = screenGui

                TweenService:Create(celebration, TweenInfo.new(0.4, Enum.EasingStyle.Sine), {
                    BackgroundTransparency = 1
                }):Play()

                task.delay(0.5, function()
                    if celebration and celebration.Parent then
                        celebration:Destroy()
                    end
                end)
            end
        end

        lastStage = newStage
    end)
end

-- ============================================================
-- AMBIENT SECTION PARTICLES
-- ============================================================

local currentAmbientParts = {}

-- Theme -> ambient particle config
local themeParticles = {
    lava_volcano = {
        color = Color3.fromRGB(255, 80, 0),
        rate = 5,
        speed = NumberRange.new(1, 3),
        direction = Enum.NormalId.Top,
        lifetime = NumberRange.new(2, 4),
        lightEmission = 0.8,
    },
    ice_crystal = {
        color = Color3.fromRGB(200, 230, 255),
        rate = 8,
        speed = NumberRange.new(0.5, 2),
        direction = Enum.NormalId.Top,
        lifetime = NumberRange.new(3, 5),
        lightEmission = 0.3,
    },
    neon_cyber = {
        color = Color3.fromRGB(255, 0, 255),
        rate = 3,
        speed = NumberRange.new(1, 4),
        direction = Enum.NormalId.Top,
        lifetime = NumberRange.new(1, 3),
        lightEmission = 1,
    },
    space_galaxy = {
        color = Color3.fromRGB(100, 50, 200),
        rate = 6,
        speed = NumberRange.new(0.3, 1),
        direction = Enum.NormalId.Top,
        lifetime = NumberRange.new(4, 8),
        lightEmission = 0.9,
    },
}

local function clearAmbientParticles()
    for _, obj in ipairs(currentAmbientParts) do
        if obj and obj.Parent then
            obj:Destroy()
        end
    end
    currentAmbientParts = {}
end

local function createAmbientParticles(theme)
    clearAmbientParticles()

    local config = themeParticles[theme]
    if not config then return end

    local character = player.Character
    if not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local attachment = Instance.new("Attachment")
    attachment.Name = "AmbientAttachment"
    attachment.Position = Vector3.new(0, 5, 0)
    attachment.Parent = rootPart

    local particles = Instance.new("ParticleEmitter")
    particles.Texture = "rbxassetid://6823373478"
    particles.Rate = config.rate
    particles.Speed = config.speed
    particles.Lifetime = config.lifetime
    particles.SpreadAngle = Vector2.new(180, 180)
    particles.EmissionDirection = config.direction
    particles.Color = ColorSequence.new(config.color)
    particles.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.7),
        NumberSequenceKeypoint.new(1, 1),
    })
    particles.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.2),
        NumberSequenceKeypoint.new(1, 0.1),
    })
    particles.LightEmission = config.lightEmission
    particles.Parent = attachment

    table.insert(currentAmbientParts, attachment)
end

if SectionChangedEvent then
    SectionChangedEvent.OnClientEvent:Connect(function(data)
        if data and data.sectionTheme then
            createAmbientParticles(data.sectionTheme)
        end
    end)
end

-- Clean up ambient particles on respawn
player.CharacterAdded:Connect(function()
    clearAmbientParticles()
end)

print("[ClientEffects] Initialized")
'''

